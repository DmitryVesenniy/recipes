#################################################
# создание ключа
ssh-keygen -t rsa

# получить ключ
cat ~/.ssh/id_rsa.pub

# Копируем ключь в гитХаб, гитЛаб и т.д.

##################################################
# Получить инфо про репозиторий
cat .git/config

# меняем имя пользователя
git config --global user.name "John Doe"

# Выбор редактора
git config --global core.editor nano

# Проверка настроек
git config --list

# Изменить origin url
git remote set-url origin git@github.com:OSLL/git_course_example_repo.git
git remote -v

# восстанавливает файлы на сцене, а именно копирует файлы из последнего коммита на сцену.
# Используйте эту команду для отмены изменений, внесённых командой git
git reset -- файлы

# копирует файлы со сцены в рабочую директорию.
# Эту команду удобно использовать, чтобы сбросить нежелательные изменения в рабочей директории.
#  отменяет все незакомиченные изменения в файле
git checkout -- файлы

# Перемещение файла с добавлением в индекс
git mv hello.html lib

# Удаление файлов из гита и из рабочей директории
git rm file
git rm --cached file # удаляем файл только из области индексирования “Staging Area”

# Commit
git commit -a # Зафиксировать (закоммитить) изменения во всех файлах (но файлы, которые не находятся в индексе, будут проигнорированы).
git commit Makefile # Закоммитить только изменения в Makefile, проигнорировать все другие измененные файлы.

# РАБОТА С ВЕТКАМИ
# git-checkout - позволяет переключаться между ветками (коммитами, тегами) или восстановить файлы рабочего каталога.
git checkout [options] [<branch>]/<commit>/<tag>
git checkout [options] <file_name_to_restore>

# Переход к коммиту с тегом HEAD
git checkout HEAD

# Переход к коммиту, предшествующему HEAD на 4
git checkout HEAD~4

# Найти хеш коммита с использованием git log и перейти к этому коммиту
git log --grep="Commit message fragment"
git checkout b20eb8bdb8daf5fcec3ceb191c6b9b25507376ca

# Отменить незакоммиченные изменения в файле file.txt
git checkout -- file.txt

#ветка - создать и перейти
git checkout -b name

#Просто создать
git branch name

#Перейти
git checkout name

# Объединить текущую ветку с name
git merge name

# %h - хэш коммита, $an - имя автора, %ar - относительная дата, %s- сообщение коммита.
git log --pretty=format:"%h - %an, %ar : %s"

# Подробная история коммитов ()
git log --stat

# stash сохраняет текущее состояние репозитория, то есть измененные отслеживаемые файлы, без создания коммита.
# Неотслеживаемые файлы в stash не включаются.
git stash

# Для просмотра записей в stash можно воспользоваться параметром list:
git stash list

# Для возврата сохраненных изменений можно воспользоваться командами git stash pop или git stash apply. 
# Если записей в  stash несколько, можно указать индекс записи, которую необходимо применить (указана в фигурных скобках). 
# Если индекс не указан, применяются изменения последней добавленной записи:
git stash pop 0

# Для удаления записей из stash используется команда git stash drop
git stash drop 0

# Тоже что и git stash drop, только удаляет все тайники
git stash clear

# Несколько коммитов в один
git checkout master && git pull && git branch -b <НоваяВетка> && git merge <СтараяВеткаГдеМногоКомитов> --squash

# поставит все ваши комиты в конец списка всех комитов
git rebase

# изменения включаются из одну ветку в другую не посредством merge, а посредством rebase:
git rebase "another_branch"

# mожно руками отредактировать несколько ваших комитов — например склеить их, изменить коментарий:
git rebase -i {HEAD~_commit_count_|commit_hash}

# удаляет из ветки на сервере все коммиты, которых нет в локальной версии, и записывает новые.
git push -f (git push --force)

# заставляет команду завершиться с ошибкой, если в удалённом репозитории есть коммиты, добавленные другими пользователями.
git push --force-with-lease

# схлопываем коммиты
git reset --hard <commit_hash>
git merge --squash HEAD@{1}
git push --force-with-lease

# слияние веток
    # 1 способ
    git merge feature
    git log --graph

    # 2 способ !!! это может злить коллег
    git rebase master
    git checkout master
    git merge feature

    # 3 способ
    git rebase master
    git checkout master
    git merge --no-ff feature

# забираем изменения
    git pull --rebase origin

Если вы хотите изменить только сообщение вашего последнего коммита, это очень просто:
    git commit --amend

Если вы создали коммит и затем хотите изменить зафиксированный снимок, добавив или изменив файлы
    git add <file>
    git rm <file>
    git commit --amend берет вашу текущую область подготовленных изменений и делает её снимок для нового коммита.

! Вы должны быть осторожными, используя этот приём, так как при этом изменяется SHA-1 коммита. Поэтому, как и с операцией rebase — не изменяйте ваш последний коммит, если вы уже отправили его в общий репозиторий.
Колммит будет изменен, но комментарий останется прежний
    git commit --amend --no-edit

